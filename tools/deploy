#!/bin/bash -e

# NOTE: Only one specific v0 should ever make it out into the real world.
# All subsequent versions are modifications on top of v0, so v0 must be
# stable or it will change the interpretation of all other versions.
#
# TODO: This deployment script should deploy only a git-tagged v0 in
# /Volumes/CIRCUITPY, then deploy the current version exactly as it would
# be installed by the software update mechanism.

cd $(dirname "$0")
cd ..

while [[ $1 = -* ]]; do
  [[ $1 = -d ]] && debug_memory=yes
  [[ $1 = -s ]] && simulator=yes
  [[ $1 = -h || $1 = --help ]] && cat <<EOF && exit 1
Usage: $0 [-d] [-q]

Wipes the attached CircuitPython device and deploys the code in the current
directory as v0, thus leaving the device in the factory reset state.  Also
installs a current copy of clock.json, fetched from the API if possible.

-d enables memory debugging: memory layout is dumped with every log message.

-q does a quick deployment: the device is not wiped; code is deployed as v999.

-s deploys to a simulated filesystem at /tmp/cclock instead of a real device.
EOF
  [[ $1 = -q ]] && quick_deploy=yes
  shift
done

echo 'Checking syntax...'
python3 <<EOF || exit 1
import os
import sys
sys.path.append('simulator')
from app import run
for name in os.listdir():
    if name.endswith('.py'):
        compile(open(name).read(), name, 'exec')
EOF

drive=/Volumes/CIRCUITPY
[[ $simulator ]] && mkdir -p /tmp/cclock && drive=/tmp/cclock

if [[ ! -d $drive ]]; then
    echo -n "Waiting for drive to appear at $drive.."
    while [[ ! -d $drive ]]; do
        echo -n '.'
        sleep 0.05
    done
    sleep 0.5  # wait for drive to become writable after boot
    echo
fi

if [[ ! -d $drive ]]; then
    echo "No drive found at $drive.  Is a CircuitPython device connected?"
    exit 1
fi

if ! touch "$drive/test"; then
    echo "$drive appears to be in read-only mode."
    exit 1
fi
rm -f "$drive/test"

if [[ -n $quick_deploy ]]; then
    version=v999
else
    echo
    echo "This will wipe $drive and perform a factory reset,"
    echo "with the current Climate Clock codebase deployed as v0."
    echo
    echo -n "Proceed? "
    read confirm
    echo

    [[ $confirm = y* ]] || exit 1

    echo "Wiping $drive..."
    rm -rf $drive/*

    # Embed the git commit ID in the directory name so it shows up in the logs.
    version=v0.$(git describe --always --match='' --dirty)
fi

target=$drive/$version
rm -rf $target
mkdir -p $target

echo "Installing program modules at $target..."
for file in *.py; do
    if [[ $file = boot.py || $file = main.py ]]; then
        cp $file "$drive"
    elif [[ $simulator ]]; then
        cp $file "$target"
    else
        env/bin/mpy-cross -o "$target"/${file%.py}.mpy $file
    fi
done

echo 'Gathering imports...'
# Do all the imports at once, to reduce memory fragmentation and get a
# consistent measurement of the memory and time consumed by each import.
(
    [[ $debug_memory ]] && echo 'import time; time.sleep(2)'
    echo 'import gc'
    echo 'gc.collect(); before = gc.mem_free()'
    echo 'import utils'
    echo 'gc.collect(); after = gc.mem_free()'
    echo "print(f'[{after} free] import utils [{before - after} used]')"
    [[ $debug_memory ]] && echo 'utils.debug = 1'
    echo "utils.log('Starting imports')"
    for module in $(tools/sort_imports start); do
        [[ $debug_memory ]] && echo 'utils.log()'
        echo "import $module"
        [[ $debug_memory ]] && echo "utils.log('import $module')"
    done
    echo "utils.log('Finished imports')"
) >/tmp/imports.py

sed -e /#IMPORTS#/r/tmp/imports.py <start.py >/tmp/start.py
env/bin/mpy-cross -s start.py -o "$target"/start.mpy /tmp/start.py
rm -f /tmp/imports.py /tmp/start.py

echo 'Installing fonts...'
cp *.mcf "$target"/

if [[ ! -f "$drive"/data/clock.json ]]; then
    echo 'Installing initial copy of clock.json...'
    mkdir -p "$drive"/data
    # Try to fetch it from the API, or use the file cached by tools/setup.
    curl -s -o "$drive"/data/clock.json --connect-timeout 2 https://api.climateclock.world/v1/clock || \
        cp cache/clock.json "$drive"/data/clock.json
fi

touch "$target"/@VALID
touch "$target"/@ENABLED
echo $version > "$target"/@PATH
echo
sync
echo 'All done!'
