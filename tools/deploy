#!/bin/bash -e

# NOTE: Only one specific v0 should ever make it out into the real world.
# All subsequent versions are modifications on top of v0, so v0 must be
# stable or it will change the interpretation of all other versions.
#
# TODO: This deployment script should deploy only a git-tagged v0 in
# /Volumes/CIRCUITPY, then deploy the current version exactly as it would
# be installed by the software update mechanism.

cd $(dirname "$0")
source functions.sh
cd ..

if [[ -d /Volumes ]]; then
    drive=/Volumes/CIRCUITPY
else
    drive=/media/$USER/CIRCUITPY
fi
drive=${CCLOCK_TARGET_ROOT:-$drive}
sim_root=${CCLOCK_SIMULATOR_ROOT:-/tmp/cclock}

while [[ $1 = -* ]]; do
    [[ $1 = -d ]] && export CCLOCK_MEMORY_DEBUGGING=1
    [[ $1 = -f ]] && factory=yes
    [[ $1 = -h || $1 = --help ]] && help=yes
    [[ $1 = -p ]] && shift && wifi_password="$1"
    [[ $1 = -s ]] && drive="$sim_root" && export CCLOCK_SIMULATOR_MODE=1
    [[ $1 = -S ]] && shift && drive="$1" && export CCLOCK_SIMULATOR_MODE=1
    [[ $1 = -w ]] && shift && wifi_ssid="$1"
    shift || break
done
vname="$1"
[[ $factory ]] && vname=v0

if [[ $help || ! $vname ]]; then
    cat <<EOF && exit 1
Usage: $0 [-d] [-f] [-s] [-S <dir>] [-w <network> -p <password>] <vname>

Deploys the code in the current directory to the attached CircuitPython device
at $drive.  (To change the target, set \$CCLOCK_TARGET_ROOT.)

<vname> should be a version name in the form v1, v2, etc.

-d enables memory debugging: memory layout is dumped with every log message.

-f factory-resets the device by wiping the flash disk, deploying v0, and
installing clock.json (fetching an up-to-date copy from the API if possible).

-s deploys to a simulated filesystem at $sim_root instead of a real device.

-S deploys to a simulated filesystem at the specified directory.

-w and -p set the initial Wi-Fi network and password when factory-resetting.
EOF
fi

echo 'Checking syntax...'
python3 <<EOF || exit 1
import os
import sys
sys.path.append('simulator')
from app import run
for name in os.listdir():
    if name.endswith('.py'):
        compile(open(name).read(), name, 'exec')
EOF

[[ $CCLOCK_SIMULATOR_MODE ]] && mkdir -p "$drive"

if [[ ! -d $drive ]] || ! touch "$drive/test" 2>/dev/null; then
    echo -n "Waiting for $drive to be writable.."
    while [[ ! -d $drive ]] || ! touch "$drive/test" 2>/dev/null; do
        echo -n '.'
        sleep 0.05
    done
    sleep 0.5  # wait for drive to become writable after boot
    rm -f "$drive/test"
    echo
fi

echo "Building $vname..."
pack_dir=/tmp/pack.$$
build_to $pack_dir
# Use tools/pack to find the pack hash, which goes in the directory name.
eval $(tools/pack -n $vname $pack_dir)
version=$vname.$pack_hash
target=$drive/$version

if [[ $factory ]]; then
    echo "Wiping $drive and installing bootstrap code..."
    rm -rf $drive/*
    cp boot.py main.py "$drive"
    mkdir -p "$drive"/data
    if [[ $wifi_ssid || $wifi_password ]]; then
        echo -n 'Setting Wi-Fi network to "'$wifi_ssid'" and '
        echo 'password to "'$wifi_password'"...'
        cat <<EOF >"$drive"/data/prefs.json
{"wifi_ssid": "$wifi_ssid", "wifi_password": "$wifi_password"}
EOF
    fi
fi

echo "Installing $vname at $target..."
mkdir -p "$target"
cp $pack_dir/* "$target"
[[ $CCLOCK_KEEP_TEMP_FILES ]] || rm -rf $pack_dir

if [[ $factory ]]; then
    echo 'Installing factory copy of clock.json...'
    # Try to fetch it from the API, or use the file cached by tools/setup.
    url=https://api.climateclock.world/v1/clock
    curl -s -o "$drive"/clock.json --connect-timeout 2 $url || \
        cp cache/clock.json "$drive"/clock.json
fi

touch "$target"/@VALID
touch "$target"/@ENABLED
sync

# Occasionally, I've seen filesystem corruption.  I'm not sure if it happens
# during deployment, but unmounting might reduce the risk.
if [[ $factory && ! $CCLOCK_SIMULATOR_MODE ]]; then
    [ -f /usr/bin/hdiutil ] && hdiutil eject $drive
    [ -e $drive ] && [ -f /*bin/umount ] && umount $drive
fi

echo
echo 'All done!'
